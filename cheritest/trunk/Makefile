#
# Copyright (c) 2013-2014 Alan A. Mujumdar
# Copyright (c) 2014 SRI International
# Copyright (c) 2012 Benjamin Thorner
# Copyright (c) 2013-2015 Colin Rothwell
# Copyright (c) 2012, 2014 David T. Chisnall
# Copyright (c) 2011-2014 Jonathan Woodruff
# Copyright (c) 2012-2015 Michael Roe
# Copyright (c) 2015 Paul J. Fox
# Copyright (c) 2012 Philip Paeps
# Copyright (c) 2011-2014 Robert M. Norton
# Copyright (c) 2011-2012 Robert N. M. Watson
# Copyright (c) 2011 William M. Morland
# Copyright (c) 2014 Joseph Stoy
# Copyright (c) 2011-2012 Steven J. Murdoch
#
# All rights reserved.
#
# This software was developed by SRI International and the University of
# Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237
# ("CTSRD"), as part of the DARPA CRASH research programme.
# This software was developed by SRI International and the University of
# Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-11-C-0249
# ("MRC2"), as part of the DARPA MRC research programme.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#


# Build system for CHERI regression tests.  Tests fall into three categories:
#
# "raw" -- which run without any prior software initialisation.  This is used
# only for a few very early tests, such as checking default register values on
# reset.  These tests must explicitly dump the register file and terminate the
# simulation.  Source file names must match the pattern "test_raw_*.s".
#
# "test" -- some amount of software setup and tear-down, but running without
# the TLB enabled.  Tests implement a "test" function that accepts neither
# arguments nor returns values.  The framework will dump registers and
# terminate the simulator on completion.  This is suitable for most forms of
# tests, but not those that need to test final values of $ra, for example.
# Source file names must match the pattern "test_*.s".
#
# "c" -- tests written in the C language; similar to the "test" category, but
# based on a .c input file containing a single function test() with similar
# properties to the "test" case.  Source file names must match the pattern
# "test_*.c".
#
# "fuzz" -- tests generated by the fuzz tester. These have setup and teardown
# similar to the ordinary 'test' but with some differences because they have
# to run on gxemul which currently doesn't support cp2 etc. To generate tests
# run 'make fuzz_generate' then to run them use 'make nose_fuzz[_cached]'.
#
# As a further dimension, each test is run in two forms: at the default start
# address in the uncached xkphys region, and relocated to the cached xkphys
# region.  The latter requires an additional instructions to jump to the
# cached start location when the test begins.  Notice that there are .celf,
# .cmem, etc, indicating the version linked for cached instructions.
#
# Each test is accompanied by a Nose test case file, which analyses registers
# from the simulator run to decide if the test passed or not.  The Nose test
# framework drives each test, checks results, and summarises the test run on
# completion.
#
# Tests are run in the order listed in TEST_FILES; it is recommended they be
# sorted by rough functional dependence on CPU features.
#
# All tests must be in the $(TESTDIR) tree; if you add new sub-directories,
# remember to add them to $(TESTDIRS).  Some tests are annotated with Nose
# attributes so that they will be excluded on gxemul -- see GXEMUL_NOSEFLAGS.
#
# "make" builds all the required parts
# "make test" runs the tests through CHERI
# "make gxemul-test" runs the tests through gxemul
#
TEST_CP2?=0
CLANG?=0
MULTI?=0
MT?=0
DMA?=0
DMA_VIRT?=0
RMA?=0
FUZZ_DMA?=0
FUZZ_DMA_ONLY?=0
# Can be set to 1 on command line to disable fuzz tests, which can be useful at times.
NOFUZZ?=0
NOFUZZR?=0


#
# List of directories in which to find test source and .py files.
#
TESTDIR=tests
TESTDIRS=					\
		$(TESTDIR)/framework		\
		$(TESTDIR)/alu			\
		$(TESTDIR)/branch		\
		$(TESTDIR)/tlb			\
		$(TESTDIR)/mem			\
		$(TESTDIR)/cache		\
		$(TESTDIR)/cp0			\
		$(TESTDIR)/cp2			\
		$(TESTDIR)/c			\
		$(TESTDIR)/mt			\
		$(TESTDIR)/pic			\
		$(TESTDIR)/dma			

ifeq ($(MULTI),1)
TESTDIRS+= $(TESTDIR)/multicore
endif

ifeq ($(MT),1)
TESTDIRS+= $(TESTDIR)/mt
endif

ifneq ($(NOFUZZ),1)
TESTDIRS+= $(TESTDIR)/fuzz
endif

ifneq ($(NOFUZZR),1)
TESTDIRS+=$(TESTDIR)/fuzz_regressions
endif

ifeq ($(FUZZ_DMA),1)
TESTDIRS+=$(TESTDIR)/fuzz_dma
endif

ifeq ($(BRIEF_GXEMUL),1)
GXEMUL_LOG_FILTER=grep -A100 'cpu0:    pc = '
else
GXEMUL_LOG_FILTER=cat
endif

ifdef COP1
TESTDIRS+= $(TESTDIR)/fpu
endif

ifdef COP1_ONLY
TESTDIRS= $(TESTDIR)/fpu
endif

ifdef TEST_TRACE
TESTDIRS+= $(TESTDIR)/trace
endif

ifdef TEST_TRACE_ONLY
TESTDIRS= $(TESTDIR)/trace
endif

ifdef RMA
TESTDIRS+= $(TESTDIR)/rma
endif

RAW_FRAMEWORK_FILES=				\
		test_raw_template.s		\
		test_raw_cp2_template.s		\
		test_raw_reg_init.s		\
		test_raw_hilo.s			\
		test_raw_dli.s			\
		test_raw_dli_sign.s		\
		test_raw_reg_name.s		\
		test_raw_nop.s			\
		test_raw_ssnop.s		\
		test_raw_lui.s			\
		test_raw_counterdev.s		\
		test_raw_movz_zero.s

RAW_ALU_FILES=					\
		test_raw_add.s			\
		test_raw_add_ex.s		\
		test_raw_addi.s			\
		test_raw_addi_ex.s		\
		test_raw_addiu.s		\
		test_raw_addiu_ex.s		\
		test_raw_addu.s			\
		test_raw_addu_ex.s		\
		test_raw_and.s			\
		test_raw_arithmetic_combo.s	\
		test_raw_sub.s			\
		test_raw_sub_ex.s		\
		test_raw_subu.s			\
		test_raw_subu_ex.s		\
		test_raw_dadd.s			\
		test_raw_daddi.s		\
		test_raw_daddiu.s		\
		test_raw_daddu.s		\
		test_raw_dsub.s			\
		test_raw_dsubu.s		\
		test_raw_andi.s			\
		test_raw_nor.s			\
		test_raw_or.s			\
		test_raw_ori.s			\
		test_raw_xor.s			\
		test_raw_xori.s			\
		test_raw_sll.s			\
		test_raw_sllv.s			\
		test_raw_srl.s			\
		test_raw_srl_ex.s		\
		test_raw_srlv.s			\
		test_raw_srlv_ex.s		\
		test_raw_sra.s			\
		test_raw_sra_ex.s		\
		test_raw_srav.s			\
		test_raw_srav_ex.s		\
		test_raw_dsll.s			\
		test_raw_dsllv.s		\
		test_raw_dsll32.s		\
		test_raw_dsrl.s			\
		test_raw_dsrlv.s		\
		test_raw_dsrl32.s		\
		test_raw_dsra.s			\
		test_raw_dsrav.s		\
		test_raw_dsra32.s

RAW_BRANCH_FILES=				\
		test_raw_jump.s			\
		test_raw_b.s			\
		test_raw_b_maxoffset.s		\
		test_raw_beq_eq.s		\
		test_raw_beq_eq_back.s		\
		test_raw_beq_gt.s		\
		test_raw_beq_lt.s		\
		test_raw_beql_eq.s		\
		test_raw_beql_eq_back.s		\
		test_raw_beql_gt.s		\
		test_raw_beql_lt.s		\
		test_raw_bgez_eq.s		\
		test_raw_bgez_eq_back.s		\
		test_raw_bgez_gt.s		\
		test_raw_bgez_lt.s		\
		test_raw_bgezal_eq.s		\
		test_raw_bgezal_eq_back.s	\
		test_raw_bgezal_gt.s		\
		test_raw_bgezal_lt.s		\
		test_raw_bgezall_eq.s		\
		test_raw_bgezall_eq_back.s	\
		test_raw_bgezall_gt.s		\
		test_raw_bgezall_lt.s		\
		test_raw_bgezl_eq.s		\
		test_raw_bgezl_eq_back.s	\
		test_raw_bgezl_gt.s		\
		test_raw_bgezl_lt.s		\
		test_raw_bgtz_eq.s		\
		test_raw_bgtz_gt_back.s		\
		test_raw_bgtz_gt.s		\
		test_raw_bgtz_lt.s		\
		test_raw_bgtzl_eq.s		\
		test_raw_bgtzl_gt_back.s	\
		test_raw_bgtzl_gt.s		\
		test_raw_bgtzl_lt.s		\
		test_raw_blez_eq_back.s		\
		test_raw_blez_eq.s		\
		test_raw_blez_gt.s		\
		test_raw_blez_lt.s		\
		test_raw_blezl_eq_back.s	\
		test_raw_blezl_eq.s		\
		test_raw_blezl_gt.s		\
		test_raw_blezl_lt.s		\
		test_raw_bltz_eq.s		\
		test_raw_bltz_gt.s		\
		test_raw_bltz_lt_back.s		\
		test_raw_bltz_lt.s		\
		test_raw_bltzal_eq.s		\
		test_raw_bltzal_gt.s		\
		test_raw_bltzal_lt_back.s	\
		test_raw_bltzal_lt.s		\
		test_raw_bltzall_eq.s		\
		test_raw_bltzall_gt.s		\
		test_raw_bltzall_lt_back.s	\
		test_raw_bltzall_lt.s		\
		test_raw_bltzl_eq.s		\
		test_raw_bltzl_gt.s		\
		test_raw_bltzl_lt.s		\
		test_raw_bltzl_lt_back.s	\
		test_raw_bne_eq.s		\
		test_raw_bne_gt.s		\
		test_raw_bne_lt_back.s		\
		test_raw_bne_lt.s		\
		test_raw_bnel_eq.s		\
		test_raw_bnel_gt.s		\
		test_raw_bnel_lt_back.s		\
		test_raw_bnel_lt.s		\
		test_raw_jr.s			\
		test_raw_jal.s			\
		test_raw_jalr.s			\
		test_raw_tlb_j.s

RAW_MEM_FILES=					\
		test_raw_lb.s			\
		test_raw_lh.s			\
		test_raw_lw.s			\
		test_raw_ld.s			\
		test_raw_ld_beq_gt_pipeline.s	\
		test_raw_load_delay_reg.s	\
		test_raw_load_delay_store.s	\
		test_raw_cache_write_to_use.s \
		test_raw_sb.s			\
		test_raw_sh.s			\
		test_raw_sw.s			\
		test_raw_sd.s			\
		test_raw_ldl.s			\
		test_raw_ldr.s			\
		test_raw_lwl.s			\
		test_raw_lwr.s			\
		test_raw_sdl.s			\
		test_raw_sdr.s			\
		test_raw_swl.s			\
		test_raw_swr.s

RAW_LLSC_FILES=					\
		test_raw_ll.s			\
		test_raw_lld.s			\
		test_raw_sc.s			\
		test_raw_scd.s

RAW_CP0_FILES=					\
		test_raw_mfc0_dmfc0.s		\
		test_raw_mtc0_sign_extend.s

RAW_CP2_FILES=					\
		test_raw_capinstructions.s

RAW_FPU_FILES =					\
		test_raw_fpu_cntrl.s		\
		test_raw_fpu_abs.s		\
		test_raw_fpu_abs_qnan.s		\
		test_raw_fpu_add.s		\
		test_raw_fpu_sub.s		\
		test_raw_fpu_mul.s		\
		test_raw_fpu_div.s		\
		test_raw_fpu_neg.s		\
		test_raw_fpu_neg_qnan.s		\
		test_raw_fpu_recip.s		\
		test_raw_fpu_sqrt.s		\
		test_raw_fpu_rsqrt.s		\
		test_raw_fpu_cf.s		\
		test_raw_fpu_cun.s		\
		test_raw_fpu_ceq.s		\
		test_raw_fpu_cueq.s		\
		test_raw_fpu_colt.s		\
		test_raw_fpu_cult.s		\
		test_raw_fpu_cole.s		\
		test_raw_fpu_cule.s		\
		test_raw_fpu_branch.s		\
		test_raw_fpu_mov_gpr.s		\
		test_raw_fpu_mov_cc.s		\
		test_raw_fpu_pair.s		\
		test_raw_fpu_cvt_paired.s	\
		test_raw_fpu_add_d32.s		\
		test_raw_fpu_sub_d32.s		\
		test_raw_fpu_mul_d32.s		\
		test_raw_fpu_div_d32.s		\
		test_raw_fpu_sqrt_d32.s		\
		test_raw_fpu_cvt_d32.s		\
		test_raw_fpu_cole_single.s	\
		test_raw_fpu_colt_single.s	\
		test_raw_fpu_cule_single.s	\
		test_raw_fpu_cult_single.s	\
		test_raw_fpu_cueq_single.s	\
		test_raw_fpu_ceq_single.s	\
		test_raw_fpu_cun_single.s	\
		test_raw_fpu_colt_d64.s		\
		test_raw_fpu_cole_d64.s		\
		test_raw_fpu_ceq_d64.s		\
		test_raw_fpu_cun_d64.s		\
		test_raw_fpu_cueq_d64.s		\
		test_raw_fpu_cule_d64.s		\
		test_raw_fpu_cult_d64.s		\
		test_raw_fpu_round_single.s	\
		test_raw_fpu_ceil_single.s	\
		test_raw_fpu_floor_single.s	\
		test_raw_fpu_trunc_single.s	\
		test_raw_fpu_qnan_single.s	\
		test_raw_fpu_qnan_s2.s		\
		test_raw_fpu_underflow.s	\
		test_raw_fpu_div_small.s	\
		test_raw_fpu_denorm.s		\
		test_raw_fpu_trunc_d64.s	\
		test_raw_fpu_trunc_l_d64.s	\
		test_raw_fpu_trunc_l_s_d64.s	\
		test_raw_fpu_floor_d64.s	\
		test_raw_fpu_floor_l_d64.s	\
		test_raw_fpu_floor_l_s_d64.s	\
		test_raw_fpu_ceil_d64.s		\
		test_raw_fpu_ceil_l_d64.s	\
		test_raw_fpu_ceil_l_s_d64.s	\
		test_raw_fpu_round_d64.s	\
		test_raw_fpu_round_l_d64.s	\
		test_raw_fpu_round_l_s_d64.s	\
		test_raw_fpu_cvt_s_w.s		\
		test_raw_fpu_cvt_s_l_d64.s	\
		test_raw_fpu_cvt_w_d_d64.s	\
		test_raw_fpu_cvt_d_w_d64.s	\
		test_raw_fpu_cvt_d_l_d64.s	\
		test_raw_fpu_cvt_l_d_d64.s	\
		test_raw_fpu_cvt_l_s_d64.s	\
		test_fpu_exception_pipeline.s	\
		test_fpu_x_disabled.s		\
		test_fpu_x_ldc1_disabled.s	\
		test_fpu_x_mthc1.s		\
		test_fpu_x_reserved.s		\
		test_raw_fpu_bc1t_pipeline.s	\
		test_raw_fpu_movt_s_pipeline.s	\
		test_raw_fpu_movf_s_pipeline.s	\
		test_raw_fpu_movt_pipeline.s	\
		test_raw_fpu_cvt.s		\
		test_raw_fpu_cvtw.s		\
		test_raw_fpu_movci.s		\
		test_raw_fpu_sd_ld.s		\
		test_raw_fpu_sw_lw.s		\
		test_raw_fpu_xc1.s		\
		test_raw_fpu_add_inf_single.s	\
		test_raw_fpu_sub_inf_single.s	\
		test_raw_fpu_mul_inf_single.s	\
		test_raw_fpu_div_inf_single.s	\
		test_raw_fpu_infinity_single.s

RAW_TRACE_FILES=test_raw_trace.s

RAW_PIC_FILES=test_raw_pic_regs.s

ifeq ($(DMA),1)
RAW_DMA_FILES=test_raw_dma_simple.s
else
RAW_DMA_FILES=
endif

ifeq ($(RMA),1)
RAW_RMA_FILES=test_raw_rma_read.s
else
RAW_RMA_FILES=
endif

TEST_FRAMEWORK_FILES=				\
		test_template.s			\
		test_reg_zero.s			\
		test_reg_forwarding.s		\
		test_dli.s			\
		test_move.s			\
		test_movz_movn_pipeline.s	\
		test_code_rom_relocation.s	\
		test_code_ram_relocation.s	\
		test_ctemplate.c		\
		test_casmgp.c			\
		test_cretval.c			\
		test_crecurse.c			\
		test_cglobals.c			\
		test_raw_jr_cachd.s

TEST_ALU_FILES=					\
		test_hilo.s			\
		test_div.s			\
		test_divu.s			\
		test_ddiv.s			\
		test_ddivu.s			\
		test_div_zero.s			\
		test_mul.s			\
		test_mul_hilo.s			\
		test_mult.s			\
		test_multu.s			\
		test_dmult.s			\
		test_dmultu.s			\
		test_madd.s			\
		test_msub.s			\
		test_maddu.s			\
		test_msubu.s			\
		test_mul_div_loop.s		\
		test_mult_exception.s		\
		test_slt.s			\
		test_slti.s			\
		test_sltiu.s			\
		test_sltu.s			\
		test_subu_carry.s

TEST_BRANCH_FILES =				\
		test_bltzall_large.s		\
		test_jalr_align.s

TEST_MEM_FILES=					\
		test_hardware_mappings.s	\
		test_hardware_mappings_write.s	\
		test_ld_cancelled.s			\
		test_memory_flush		\
		test_sd_burst.s			\
		test_storeload.s		\
		test_sync.s			\
		test_mem_alias_data.s		\
		test_raw_pism_truncation.s

TEST_LLSC_FILES=				\
		test_ll_unalign.s		\
		test_lld_unalign.s		\
		test_sc_unalign.s		\
		test_scd_unalign.s		\
		test_scd_alias.s		\
		test_llsc.s			\
		test_llsc_span.s		\
		test_lldscd.s			\
		test_lldscd_span.s		\
		test_cp0_lladdr.s

TEST_CACHE_FILES=				\
		test_hardware_mapping_cached_read.s \
		test_cache_instruction_data.s	\
		test_cache_instruction_instruction.s \
		test_cache_instruction_L2.s	\
		test_cache_taglo.s		\
		test_id_coherence.s

TEST_CP0_FILES=					\
		test_cp0_reg_init.s		\
		test_cp0_config1		\
		test_cp0_config2		\
		test_cp0_config3		\
		test_cp0_config5		\
		test_cp0_config6		\
		test_eret.s			\
		test_exception_bev0_trap.s	\
		test_exception_bev0_trap_bd.s	\
		test_break.s			\
		test_syscall.s			\
		test_syscall2.s			\
		test_syscall50.s		\
		test_syscall_cache_store.s	\
		test_teq_eq.s			\
		test_teq_gt.s			\
		test_teq_lt.s			\
		test_tge_eq.s			\
		test_tge_gt.s			\
		test_tge_lt.s			\
		test_tgeu_eq.s			\
		test_tgeu_gt.s			\
		test_tgeu_lt.s			\
		test_tlt_eq.s			\
		test_tlt_gt.s			\
		test_tlt_lt.s			\
		test_tltu_eq.s			\
		test_tltu_gt_sign.s		\
		test_tltu_gt.s			\
		test_tltu_lt.s			\
		test_tne_eq.s			\
		test_tne_gt.s			\
		test_tne_lt.s			\
		test_cp0_compare.s		\
		test_cp0_watch_instr.s		\
		test_cp0_watch_load.s		\
		test_cp0_watch_store.s		\
		test_cp0_user.s			\
		test_cp0_eret_user.s		\
		test_cp0_ri.s			\
		test_cp0_cache_user.s		\
		test_cp0_counter.s		\
		test_cp0_userlocal.s		\
		test_cp0_rdhwr_user.s		\
		test_cp0_rdhwr_user2.s		\
		test_cp0_rdhwr_counter.s	\
		test_cp0_tlbwi_user.s		\
		test_cp0_hwrenable.s		\
		test_cp0_syncistep.s		\
		test_cp0_ccres.s		\
		test_cp0_wait.s

TEST_FPU_FILES=					\
		test_fpu_exception_pipeline.s	\
		test_fpu_x_div.s		\
		test_fpu_x_underflow.s		\
		test_fpu_x_overflow.s		\
		test_fpu_x_c_nan.s

ifeq ($(TEST_CP2),1)
TEST_CP2_FILES=					\
		test_cp2_reg_init.s		\
		test_cp2_reg_name.s		\
		test_cp2_getsettype.s		\
		test_cp2_getincbase.s		\
		test_cp2_getsetleng.s		\
		test_cp2_getsetoffset.s		\
		test_cp2_csetoffset_int.s	\
		test_cp2_csetoffset_notag.s	\
		test_cp2_cincoffset.s		\
		test_cp2_cincoffset_notag.s	\
		test_cp2_getandperm.s		\
		test_cp2_getandperm_user.s	\
		test_cp2_getcleartag.s		\
		test_cp2_getunsealed.s		\
		test_cp2_getpcc.s		\
		test_cp2_cmove.s		\
		test_cp2_cscr.s			\
		test_cp2_clcr.s			\
		test_cp2_clcr_tag.s		\
		test_cp2_csci.s			\
		test_cp2_csc_neg.s		\
		test_cp2_cjr.s			\
		test_cp2_cjalr_rcc.s		\
		test_cp2_cjalr_pcc.s		\
		test_cp2_cjalr.s		\
		test_cp2_cjalr_loop.s		\
		test_cp2_kcc.s			\
		test_cp2_kr1c.s			\
		test_cp2_kr2c.s			\
		test_cp2_kdc.s			\
		test_cp2_tagmem.s		\
		test_cp2_tagstore.s		\
		test_cp2_tagstorec0.s		\
		test_cp2_cmove_tag.s		\
		test_cp2_cmove_sealed.s		\
		test_cp2_cswitch.s		\
		test_cp2_cswitch_clr.s		\
		test_cp2_cswitch_clr_20.s	\
		test_cp2_alu_mod_pipeline.s	\
		test_cp2_mem_mod_pipeline.s	\
		test_cp2_get_alu_pipeline.s	\
		test_cp2_get_mem_pipeline.s	\
		test_cp2_mod_mod_pipeline.s	\
		test_cp2_load_pipeline.s	\
		test_cp2_cldr_priv.s		\
		test_cp2_clwr_priv.s		\
		test_cp2_clhr_priv.s		\
		test_cp2_clbr_priv.s		\
		test_cp2_cldr_unpriv.s		\
		test_cp2_clwr_unpriv.s		\
		test_cp2_clhr_unpriv.s		\
		test_cp2_clbr_unpriv.s		\
		test_cp2_cld_unpriv.s		\
		test_cp2_clw_unpriv.s		\
		test_cp2_clh_unpriv.s		\
		test_cp2_clb_unpriv.s		\
		test_cp2_clbu_priv.s		\
		test_cp2_clbu_unpriv.s		\
		test_cp2_clhu_priv.s		\
		test_cp2_clhu_unpriv.s		\
		test_cp2_clwu_priv.s		\
		test_cp2_clwu_unpriv.s		\
		test_cp2_zeroex.s		\
		test_cp2_signex.s		\
		test_cp2_csealcode.s		\
		test_cp2_csealunsealcode.s	\
		test_cp2_csealdata.s		\
		test_cp2_c0_ld.s		\
		test_cp2_c0_lwu.s		\
		test_cp2_c0_lhu.s		\
		test_cp2_c0_lbu.s		\
		test_cp2_csd_unpriv.s		\
		test_cp2_csw_unpriv.s		\
		test_cp2_csh_unpriv.s		\
		test_cp2_csb_unpriv.s		\
		test_cp2_csdr_unpriv.s		\
		test_cp2_cswr_unpriv.s		\
		test_cp2_cshr_unpriv.s		\
		test_cp2_csbr_unpriv.s		\
		test_cp2_csdr_priv.s		\
		test_cp2_cswr_priv.s		\
		test_cp2_cshr_priv.s		\
		test_cp2_csbr_priv.s		\
		test_cp2_c0_sd.s		\
		test_cp2_c0_sw.s		\
		test_cp2_c0_sh.s		\
		test_cp2_c0_sb.s		\
		test_cp2_exception_epcc.s	\
		test_cp2_exception_pipeline.s	\
		test_cp2_tlb_exception_fill.s	\
		test_cp2_tlb_instruction_miss.s \
		test_cp2_cmove_j.s		\
		test_cp2_c0_notag.s		\
		test_cp2_c0_perm.s		\
		test_cp2_c0_sealed.s		\
		test_cp2_clld.s			\
		test_cp2_clld_span.s		\
		test_cp2_ccall.s		\
		test_cp2_creturn_trap.s		\
		test_cp2_ccall2.s		\
		test_cp2_cbtu.s			\
		test_cp2_cbts.s			\
		test_cp2_ceq.s			\
		test_cp2_cne.s			\
		test_cp2_clt.s			\
		test_cp2_cle.s			\
		test_cp2_cltu.s			\
		test_cp2_cleu.s			\
		test_cp2_branchtag.s		\
		test_cp2_floatstore.s		\
		test_cp2_csb_neg.s		\
		test_cp2_csetcause.s		\
		test_cp2_sbx_j.s		\
		test_cp2_sandbox_jal.s		\
		test_cp2_ccheckperm.s		\
		test_cp2_cchecktype.s		\
		test_cp2_cfromptr.s		\
		test_cp2_ctoptr.s		\
		test_cp2_ctoptr_null.s		\
		test_cp2_ctoptr_zero.s		\
		test_cp2_ctoptr_bounds.s	\
		test_cp2_ctoptr_tag.s	\
		test_cp2_cfromptr_null.s	\
		test_cp2_x_bounds.s		\
		test_cp2_x_clbu_tag.s		\
		test_cp2_x_clbu_reg.s		\
		test_cp2_x_clbu_perm.s		\
		test_cp2_x_clbu_sealed.s	\
		test_cp2_x_csb_perm.s		\
		test_cp2_x_csc_align.s		\
		test_cp2_x_csc_vaddr.s		\
		test_cp2_x_csc_ephemeral.s	\
		test_cp2_csc_ephemeral_invalid.s\
		test_cp2_x_csc_perm.s		\
		test_cp2_x_csc_underflow.s	\
		test_cp2_x_clc_perm.s		\
		test_cp2_x_clc_align.s		\
		test_cp2_x_clc_vaddr.s		\
		test_cp2_x_clc_priority.s	\
		test_cp2_x_clc_bounds.s		\
		test_cp2_x_cunseal_otype.s	\
		test_cp2_x_cunseal_perm.s	\
		test_cp2_x_csealdata_tag.s	\
		test_cp2_x_csealdata_reg.s	\
		test_cp2_x_csealdata_perm.s	\
		test_cp2_x_cgetbase_reg.s	\
		test_cp2_x_cgetlen_reg.s	\
		test_cp2_x_cgettag_reg.s	\
		test_cp2_x_cgetunsealed_reg.s	\
		test_cp2_x_cgetperm_reg.s	\
		test_cp2_x_cgettype_reg.s	\
		test_cp2_x_cgetpcc_reg.s	\
		test_cp2_x_cgetcause_perm.s	\
		test_cp2_x_csetcause_perm.s	\
		test_cp2_x_cincbase_tag.s	\
		test_cp2_x_csetlen_tag.s	\
		test_cp2_x_candperm_tag.s	\
		test_cp2_x_cjalr_tag.s		\
		test_cp2_cunseal_ephemeral.s	\
		test_cp2_x_cunseal_unsealed.s	\
		test_cp2_x_cld_priority.s	\
		test_cp2_x_cld_pri2.s		\
		test_cp2_x_fetch.s		\
		test_cp2_x_cjalr_perm.s		\
		test_cp2_x_cjr_ephemeral.s	\
		test_cp2_x_cjalr_ephemeral.s	\
		test_cp2_x_sb_perm.s		\
		test_cp2_x_lb_perm.s		\
		test_cp2_x_lb_tag.s		\
		test_cp2_x_lb_sealed.s		\
		test_cp2_x_cincbase_delay.s	\
		test_cp2_x_cincbase_delay2.s	\
		test_cp2_x_cbtu_reg.s		\
		test_cp2_x_cbts_reg.s		\
		test_cp2_x_csettype_perm.s	\
		test_cp2_x_csettype_bounds.s	\
		test_cp2_x_swc1_perm.s		\
		test_cp2_x_sdc1_perm.s		\
		test_cp2_disabled_exception.s	\
		test_cp2_x_ccheckperm.s		\
		test_cp2_x_ccheckperm_2.s	\
		test_cp2_x_cchecktype.s		\
		test_cp2_x_clc_tlb.s		\
		test_cp2_x_csc_tlb.s		\
		test_cp2_csc_tlb.s		\
		test_cp2_x_csetoffset_sealed.s	\
		test_cp2_x_cincoffset_sealed.s	\
		test_cp2_x_ccall_type
endif

TEST_ALU_OVERFLOW_FILES=			\
		test_add_overflow.s		\
		test_add_overflow_wrong_sign.s  \
		test_addi_overflow.s		\
		test_addiu_overflow.s		\
		test_addu_overflow.s		\
		test_dadd_overflow.s		\
		test_daddi_overflow.s		\
		test_daddiu_overflow.s		\
		test_daddu_overflow.s		\
		test_dsub_overflow.s		\
		test_dsub_overflow_minint.s	\
		test_dsubu_overflow.s		\
		test_sub_overflow.s		\
		test_sub_overflow_minint.s	\
		test_subu_overflow.s		\
		test_madd_lo_overflow.s		\
		test_subu_overflow.s

TEST_MEM_UNALIGN_FILES=				\
		test_lh_unalign.s		\
		test_lw_unalign.s		\
		test_ld_unalign.s		\
		test_sh_unalign.s		\
		test_sw_unalign.s		\
		test_sd_unalign.s		\
		test_beq_lb.s

TEST_BEV1_FILES=				\
		test_exception_bev1_trap.s


TEST_TLB_FILES=					\
		test_tlb_load_0.s		\
		test_tlb_load_1.s		\
		test_tlb_load_1_large_page.s	\
		test_tlb_probe.s		\
		test_tlb_exception_fill.s	\
		test_tlb_instruction_miss.s	\
		test_tlb_load_max.s		\
		test_tlb_load_asid.s		\
		test_tlb_read.s			\
		test_tlb_store_0.s		\
		test_tlb_store_protected.s	\
		test_tlb_user_mode.s		\
		test_tlb_invalid_load.s		\
		test_tlb_invalid_store.s	\
		test_tlb_addrerr_load.s		\
		test_tlb_addrerr_store.s	\
		test_tlb_wired.s                \
		test_tlb_ext_enable.s		\
		test_tlb_tlbwr.s		\
		test_tlb_tlbwr_ext.s

TEST_TRAPI_FILES=				\
		test_teqi_eq.s			\
		test_teqi_gt.s			\
		test_teqi_lt.s			\
		test_teqi_eq_sign.s		\
		test_tgei_eq.s			\
		test_tgei_gt.s			\
		test_tgei_lt.s			\
		test_tgei_eq_sign.s		\
		test_tgei_gt_sign.s		\
		test_tgei_lt_sign.s		\
		test_tgeiu_eq.s			\
		test_tgeiu_gt.s			\
		test_tgeiu_lt.s			\
		test_tlti_eq.s			\
		test_tlti_gt.s			\
		test_tlti_lt.s			\
		test_tlti_eq_sign.s		\
		test_tlti_gt_sign.s		\
		test_tlti_lt_sign.s		\
		test_tltiu_eq.s			\
		test_tltiu_gt_sign.s		\
		test_tltiu_gt.s			\
		test_tltiu_lt.s			\
		test_tnei_eq_sign.s		\
		test_tnei_eq.s			\
		test_tnei_gt_sign.s		\
		test_tnei_gt.s			\
		test_tnei_lt_sign.s		\
		test_tnei_lt.s

TEST_PIC_FILES=test_pic_irq.s

# Don't attempt to build clang tests unless CLANG is set to 1, because clang might not be available
# This will cause clang tests to fail but that is better than make falling over.
# The DMA engine also depends on clang, and works in the same way
ifeq ($(CLANG),1)

ifeq ($(DMA), 1)
TEST_DMA_FILES=					\
		test_clang_dma_simple.c		\
		test_clang_dma_byte.c		\
		test_clang_dma_line.c		\
		test_clang_dma_loop.c		\
		test_clang_dma_add.c		\
		test_clang_dma_sub.c		\
		test_clang_dma_big_dram.c	\
		test_clang_dma_long_program.c	\
		test_clang_dma_successive_programs.c \
		test_clang_dma_nested_loop.c	\
		test_clang_dma_irq.c
else
TEST_DMA_FILES=
endif

ifeq ($(DMA_VIRT), 1)
TEST_DMA_FILES+=test_clang_dma_virt_translate.c
endif

TEST_CLANG_FILES=				\
		test_clang_cast.c		\
		test_clang_cursor.c		\
		test_clang_cursor_trivial.c	\
		test_clang_toy.c		\
		test_clang_memcpy.c		\
		test_clang_load_data.c		\
		test_clang_store_data.c		\
		test_clang_struct.c		\
		test_clang_opaque.c		\
		test_clang_load_float.c		\
		test_clang_load_double.c	\
		test_clang_pack.c
else
TEST_CLANG_FILES=
endif

ifeq ($(MULTI),1)
TEST_MULTICORE_FILES=				\
		test_raw_coherence_setup.s	\
		test_raw_coherence_mp_loop.s	\
		test_raw_coherence_sequential.s	\
		test_mc_pics.s			\
		test_mc_pic_irq.s		\
		test_mc_rdhwr.s			\
		test_mc_rdhwr_core.s		\
		test_mc_coherence_sequential.s	\
		test_mc_llsc.s			\
		test_mc_llsc_alias.s		\
		test_mc_core0_first.s		\
		test_mc_core0_last.s		\
		test_mc_tag_coherence.s
else
TEST_MULTICORE_FILES=
endif

ifeq ($(MT),1)
TEST_MT_FILES=					\
		test_ipc.s			\
		test_mt_rdhwr.s
else
TEST_MT_FILES=
endif

ifeq ($(RMA), 1)
TEST_RMA_FILES = test_raw_rma_read.s
else
TEST_RMA_FILES=
endif

FUZZ_SCRIPT:=fuzzing/fuzz.py
FUZZ_SCRIPT_OPTS?=
FUZZ_TEST_DIR:=tests/fuzz
ifneq ($(NOFUZZ),1)
FUZZ_TEST_FILES:=$(notdir $(wildcard $(FUZZ_TEST_DIR)/*.s))
endif
ifneq ($(NOFUZZR),1)
FUZZ_REGRESSION_TEST_DIR:=tests/fuzz_regressions/
FUZZ_REGRESSION_TEST_FILES:=$(notdir $(wildcard $(FUZZ_REGRESSION_TEST_DIR)/*.s))
else
FUZZ_REGRESSION_TEST_DIR:=
FUZZ_REGRESSION_TEST_FILES:=
endif

ifeq ($(FUZZ_DMA), 1)
FUZZ_DMA_FILES:=$(notdir $(wildcard tests/fuzz_dma/*.c))
else
FUZZ_DMA_FILES:=
endif
#
# All unit tests.  Implicitly, these will all be run for CHERI, but subsets
# may be used for other targets.
#
TEST_FILES=					\
		$(RAW_FRAMEWORK_FILES)		\
		$(RAW_ALU_FILES)		\
		$(RAW_BRANCH_FILES)		\
		$(RAW_MEM_FILES)		\
		$(RAW_LLSC_FILES)		\
		$(RAW_CP0_FILES)		\
		$(RAW_PIC_FILES)		\
		$(TEST_FRAMEWORK_FILES)		\
		$(TEST_ALU_FILES)		\
		$(TEST_BRANCH_FILES)		\
		$(TEST_MEM_FILES)		\
		$(TEST_LLSC_FILES)		\
		$(TEST_CACHE_FILES)		\
		$(TEST_CP0_FILES)		\
		$(TEST_CP2_FILES)		\
		$(TEST_BEV1_FILES)		\
		$(TEST_TLB_FILES)		\
		$(TEST_ALU_OVERFLOW_FILES)	\
		$(TEST_MEM_UNALIGN_FILES)	\
		$(TEST_TRAPI_FILES)		\
		$(FUZZ_TEST_FILES)		\
		$(RAW_DMA_FILES)		\
		$(TEST_DMA_FILES)		\
		$(FUZZ_DMA_FILES)		\
		$(TEST_CLANG_FILES)		\
		$(TEST_MULTICORE_FILES)		\
		$(TEST_MT_FILES)	 	\
		$(TEST_PIC_FILES)		\
		$(RAW_RMA_FILES)


ifdef COP1
TEST_FILES+=	$(RAW_FPU_FILES) $(TEST_FPU_FILES)
endif

ifdef COP1_ONLY
TEST_FILES=	$(RAW_FPU_FILES) $(TEST_FPU_FILES)
endif

ifeq ($(FUZZ_DMA_ONLY), 1)
TEST_FILES = $(FUZZ_DMA_FILES)
endif

ifneq ($(NOFUZZR),1)
TEST_FILES+=$(FUZZ_REGRESSION_TEST_FILES)
endif

ifdef TEST_TRACE
TEST_FILES+=	$(RAW_TRACE_FILES)
else
ifdef TEST_TRACE_ONLY
TEST_FILES=	$(RAW_TRACE_FILES)
endif
endif
#
# Omit certain categories of tests due to gxemul functional omissions:
#
# llsc - gxemul terminates the simulator on load linked, store conditional
# cache - gxemul does not simulate a cache
# bev1 - gxemul does not support early boot exception vectors
# trapi - gxemul does not implement trap instructions with immediate
#         arguments
#
# Some tests are omitted as CHERI-specific:
#
# counterdev - gxemul does not provide the "counter" device used to test
#              cache semantics.
# cheri - gxemul is simply not CHERI
#
GXEMUL_NOSEFLAGS=-A "   \
not llsc                \
and not cache           \
and not bev1            \
and not trapi           \
and not counterdev      \
and not watch           \
and not capabilities    \
and not clang           \
and not beri            \
and not dumpicache	\
and not einstr		\
and not jump_unaligned	\
and not nofloat         \
and not floatpaired     \
and not floatindexed    \
and not floatcmove      \
and not floatfcsr       \
and not floatfenr       \
and not floatfexr       \
and not floatrecip      \
and not floatrsqrt      \
and not float64         \
and not floatexception  \
and not floatechonan    \
and not smalltlb        \
and not bigtlb          \
and not beri1tlb	\
and not beri2tlb	\
and not beri1cache	\
and not beri2cache	\
and not extendedtlb	\
and not enablelargetlb  \
and not invalidateL2    \
and not rdhwr           \
and not config2		\
and not config3         \
and not config5		\
and not userlocal       \
and not mt              \
and not pic		\
and not mips_overflow 	\
and not dma		\
and not dmaclang	\
"

L3_NOSEPRED=\
not beri \
and not beriinitial \
and not counterdev \
and not dma \
and not dmaclang \
and not dumpicache \
and not float \
and not ignorebadex \
and not invalidateL2 \
and not loadcachetag \
and not llscnotmatching \
and not llscspan \
and not llscnoalias \
and not mtc0signex \
and not swi \
and not syncistep \
and not smalltlb \
and not beri2tlb \
and not gxemultlb \
and not beri2cache \
and not watch \
and not deterministic_random \
and not noextendedtlb \
and not csettype

ifneq ($(TEST_CP2),1)
L3_NOSEPRED+=and not capabilities and not clang
else
L3_NOSEPRED+=and not ccall_hw_1
endif

ifneq ($(CLANG),1)
L3_NOSEPRED+=and not clang
endif

ifneq ($(MULTI),1)
L3_NOSEPRED+=and not multicore
endif

ifneq ($(MT),1)
L3_NOSEPRED+=and not mt
endif

L3_NOSEFLAGS=-A "$(L3_NOSEPRED)"
#ifdef TRACE
#define L3_TRACE --trace 2
#else
#define L3_TRACE --trace 0
#endif

#
# We unconditionally terminate the simulator after TEST_CYCLE_LIMIT
# instructions to ensure that loops terminate.  This is an arbitrary number.
#
TEST_CYCLE_LIMIT?=1500000
#TEST_CYCLE_LIMIT?=15000000

##############################################################################
# No need to modify anything below this point if you are just adding new
# tests to current categories.
#

# Set BERI_VER to 2 to test cheri2
BERI_VER?=
# Set to 0 to disable capability tests
CHERIROOT?=../../cheri$(BERI_VER)/trunk
CHERIROOT_ABS:=$(realpath $(CHERIROOT))
CHERILIBS?=../../cherilibs/trunk
CHERILIBS_ABS:=$(realpath $(CHERILIBS))
MEMCONF?=$(CHERIROOT_ABS)/memoryconfig
TRACECONF?=$(CHERIROOT_ABS)/traceconfig
TOOLS_DIR= ${CHERILIBS_ABS}/tools
TOOLS_DIR_ABS:=$(realpath $(TOOLS_DIR))
CHERICTL=$(TOOLS_DIR_ABS)/debug/cherictl
SYSTEM_CONSOLE_DIR_ABS:= /usr/groups/ecad/altera/current/quartus/sopc_builder/bin
CHERISOCKET:= /tmp/$(USER)_beri_debug_socket
SIM:= ${CHERIROOT_ABS}/sim
DTB_FILE:=$(CHERIROOT_ABS)/sim.dtb
# Can be set to a custom value to customise tracing, which is useful to avoid filling up disks when fuzz testing.
ifdef DEBUG
	SIM_TRACE_OPTS?= +trace +cTrace +tlbTrace +instructionBasedCycleCounter +debug
else
ifdef TRACE
	SIM_TRACE_OPTS?=+trace +cTrace +tlbTrace +instructionBasedCycleCounter +dma
else
	SIM_TRACE_OPTS?=
endif
endif
NOSEPRED=not false
ifeq ($(BERI_VER),2)
NOSEPRED+=and not invalidateL2only
NOSEPRED+=and not lladdr
NOSEPRED+=and not extendedtlb
NOSEPRED+=and not bigtlb
NOSEPRED+=and not gxemultlb
NOSEPRED+=and not beri1tlb
NOSEPRED+=and not beri1cache
NOSEPRED+=and not largepage
NOSEPRED+=and not dumpicache
NOSEPRED+=and not loadcachetag
else
NOSEPRED+=and not noextendedtlb
NOSEPRED+=and not smalltlb
NOSEPRED+=and not gxemultlb
NOSEPRED+=and not beri2tlb
NOSEPRED+=and not beri2cache
ifeq ($(GENERIC_L1),1)
NOSEPRED+=and not beri1cache
# The parser for the ICache dump hard-codes the size of the cache,
# so isn't expected to work if the cache size changes.
NOSEPRED+=and not dumpicache
endif
NOSEPRED+=and not syncistep
endif
ifdef COP1
NOSEPRED+=and not nofloat and not float32 and not floatexception and not floatflags and not floatrecipflushesdenorm and not floatri
ifdef WONTFIX
NOSEPRED+=and not floatpairedrounding
endif
else
NOSEPRED+=and not float
endif
ifneq ($(TEST_CP2),1)
NOSEPRED+=and not capabilities and not clang
endif
ifneq ($(CLANG),1)
NOSEPRED+=and not clang and not dmaclang
endif
ifneq ($(DMA),1)
NOSEPRED+=and not dma and not dmaclang
endif
ifneq ($(MULTI),1)
NOSEPRED+=and not multicore
else
NOSEPRED+=and not llscnoalias
endif
ifneq ($(MT),1)
NOSEPRED+=and not mt
endif
ifdef CHERI_MICRO
NOSEPRED+=and not tlb and not cache and not invalidateL2 and not bigtlb and not watch
ifdef WONTFIX
NOSEPRED+=and not jump_unaligned
endif
else
NOSEPRED+=and not nowatch
endif
ifneq ($(NOSEPRED),)
NOSEFLAGS?=-A "$(NOSEPRED) and not uncached"
NOSEFLAGS_UNCACHED?=-A "$(NOSEPRED) and not cached"
endif

VPATH=$(TESTDIRS)
OBJDIR=obj
LOGDIR=log
ALTERA_LOGDIR=altera_log
HWSIM_LOGDIR=hwsim_log
GXEMUL_LOGDIR=gxemul_log
GXEMUL_BINDIR?=/usr/groups/ctsrd/gxemul/CTSRD-CHERI-gxemul-testversion
GXEMUL_TRACE_OPTS?=-i
GXEMUL_OPTS=-u -V -E oldtestmips -M 3072 $(GXEMUL_TRACE_OPTS) -p "end"
L3_LOGDIR=l3_log

RAW_LDSCRIPT=raw.ld
RAW_CACHED_LDSCRIPT=raw_cached.ld
RAW_MULTI_LDSCRIPT=raw_multi.ld
TEST_LDSCRIPT=test.ld
TEST_CACHED_LDSCRIPT=test_cached.ld
TEST_MULTI_LDSCRIPT=test_multi.ld

TEST_INIT_OBJECT=$(OBJDIR)/init.o
# Fuzz tests have a slightly different init which doesn't dump
# capability registers and has more interesting initial register values.
TEST_INIT_CACHED_OBJECT=$(OBJDIR)/init_cached.o
TEST_INIT_MULTI_OBJECT=$(OBJDIR)/init_multi.o
TEST_LIB_OBJECT=$(OBJDIR)/lib.o

TESTS := $(basename $(TEST_FILES))
TEST_OBJS := $(addsuffix .o,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_ELFS := $(addsuffix .elf,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_CACHED_ELFS := $(addsuffix _cached.elf,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_MULTI_ELFS := $(addsuffix _multi.elf,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_CACHEDMULTI_ELFS := $(addsuffix _multi.elf,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_MEMS := $(addsuffix .mem,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_CACHED_MEMS := $(addsuffix _cached.mem,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_MULTI_MEMS := $(addsuffix _multi.mem,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_HEXS := $(addsuffix .hex,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_CACHED_HEXS := $(addsuffix _cached.hex,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_MULTI_HEXS := $(addsuffix _multi.hex,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_DUMPS := $(addsuffix .dump,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_CACHED_DUMPS := $(addsuffix _cached.dump,$(addprefix $(OBJDIR)/,$(TESTS)))
TEST_MULTI_DUMPS := $(addsuffix _multi.dump,$(addprefix $(OBJDIR)/,$(TESTS)))

TEST_PYTHON := \
	$(addsuffix .py,$(addprefix tests/framework/,$(basename $(RAW_FRAMEWORK_FILES) $(TEST_FRAMEWORK_FILES)))) \
	$(addsuffix .py,$(addprefix tests/alu/,$(basename $(RAW_ALU_FILES) $(TEST_ALU_FILES) $(TEST_ALU_OVERFLOW_FILES)))) \
	$(addsuffix .py,$(addprefix tests/branch/,$(basename $(RAW_BRANCH_FILES) $(TEST_BRANCH_FILES)))) \
	$(addsuffix .py,$(addprefix tests/cp0/,$(basename $(RAW_CP0_FILES) $(TEST_CP0_FILES) $(TEST_TRAPI_FILES) $(TEST_BEV1_FILES)))) \
	$(addsuffix .py,$(addprefix tests/cp2/,$(basename $(TEST_CP2_FILES)))) \
	$(addsuffix .py,$(addprefix tests/fpu/,$(basename $(RAW_FPU_FILES) $(TEST_FPU_FILES)))) \
	$(addsuffix .py,$(addprefix tests/mem/,$(basename $(RAW_LLSC_FILES) $(TEST_LLSC_FILES)))) \
	$(addsuffix .py,$(addprefix tests/mem/,$(basename $(RAW_MEM_FILES) $(TEST_MEM_FILES) $(TEST_MEM_UNALIGN_FILES)))) \
	$(addsuffix .py,$(addprefix tests/tlb/,$(basename $(TEST_TLB_FILES)))) \
	$(addsuffix .py,$(addprefix tests/mt/,$(basename $(TEST_MT_FILES)))) \
	$(addsuffix .py,$(addprefix tests/multicore/,$(basename $(TEST_MULTICORE_FILES))))

CHERI_TEST_LOGS := $(addsuffix .log,$(addprefix $(LOGDIR)/,$(TESTS)))
CHERI_TEST_CACHED_LOGS := $(addsuffix _cached.log,$(addprefix \
	$(LOGDIR)/,$(TESTS)))
CHERI_TEST_MULTI_LOGS := $(addsuffix _multi.log,$(addprefix \
	$(LOGDIR)/,$(TESTS)))
CHERI_TEST_CACHEDMULTI_LOGS := $(addsuffix _cachedmulti.log,$(addprefix \
	$(LOGDIR)/,$(TESTS)))
ALTERA_TEST_LOGS := $(addsuffix .log,$(addprefix $(ALTERA_LOGDIR)/,$(TESTS)))
ALTERA_TEST_CACHED_LOGS := $(addsuffix _cached.log,$(addprefix \
	$(ALTERA_LOGDIR)/,$(TESTS)))
HWSIM_TEST_LOGS := $(addsuffix .log,$(addprefix $(HWSIM_LOGDIR)/,$(TESTS)))
HWSIM_TEST_CACHED_LOGS := $(addsuffix _cached.log,$(addprefix \
	$(HWSIM_LOGDIR)/,$(TESTS)))
GXEMUL_TEST_LOGS := $(addsuffix _gxemul.log,$(addprefix \
	$(GXEMUL_LOGDIR)/,$(TESTS)))
GXEMUL_TEST_CACHED_LOGS := $(addsuffix _gxemul_cached.log,$(addprefix \
	$(GXEMUL_LOGDIR)/,$(TESTS)))
L3_TEST_LOGS := $(addsuffix .log,$(addprefix \
	$(L3_LOGDIR)/,$(TESTS)))
L3_TEST_CACHED_LOGS := $(addsuffix _cached.log,$(addprefix \
	$(L3_LOGDIR)/,$(TESTS)))
L3_TEST_MULTI_LOGS := $(addsuffix _multi.log,$(addprefix \
	$(L3_LOGDIR)/,$(TESTS)))
L3_TEST_CACHEDMULTI_LOGS := $(addsuffix _cachedmulti.log,$(addprefix \
	$(L3_LOGDIR)/,$(TESTS)))

SIM_FUZZ_TEST_LOGS := $(filter $(LOGDIR)/test_fuzz_%, $(CHERI_TEST_LOGS))
SIM_FUZZ_TEST_CACHED_LOGS := $(filter $(LOGDIR)/test_fuzz_%, $(CHERI_TEST_CACHED_LOGS))
GXEMUL_FUZZ_TEST_LOGS := $(filter $(GXEMUL_LOGDIR)/test_fuzz_%, $(GXEMUL_TEST_LOGS))
GXEMUL_FUZZ_TEST_CACHED_LOGS := $(filter $(GXEMUL_LOGDIR)/test_fuzz_%, $(GXEMUL_TEST_CACHED_LOGS))

REWRITE_PISM_CONF = sed -e 's,../../cherilibs/trunk,$(CHERILIBS_ABS),' < $(1) > $(2)
COPY_PISM_CONFS = $(call REWRITE_PISM_CONF,$(MEMCONF),$$TMPDIR/memoryconfig) && \
		  $(call REWRITE_PISM_CONF,$(TRACECONF),$$TMPDIR/traceconfig)

PREPARE_TEST = \
	TMPDIR=$$(mktemp -d) && \
	cd $$TMPDIR && \
	cp $(PWD)/$(1) mem.bin && \
	$(MEMCONV) bsim && \
	$(MEMCONV) bsimc2 && \
	$(COPY_PISM_CONFS)

# XXX rmn30
# As a hack to work around bsim license problems which cause it to sporadically fail we repeat the sim
# command several times until it succeeds. The for loop should be removed once the license server problem
# is fixed.

RUN_TEST_COMMAND = \
	LD_LIBRARY_PATH=$(CHERILIBS_ABS)/peripherals \
	CHERI_CONFIG=$$TMPDIR/simconfig \
	CHERI_DTB=$(DTB_FILE) \
	BERI_DEBUG_SOCKET_0=$(CHERISOCKET)  $(SIM) -w +regDump $(SIM_TRACE_OPTS) -m $(TEST_CYCLE_LIMIT) > \
	    $(PWD)/$@; \

REPEAT_5 = \
	for attempt in 0 1 2 4 5; do if \
	$(1) \
	then break; else false; fi; done

RUN_TEST = $(call REPEAT_5,$(RUN_TEST_COMMAND))

# XXX jes212
# Use the following version instead of the above (running a severely limited number of tests) if you wish
# to make waves (<test name>.vcd will be dumped into your home directory):
#
#RUN_TEST = \
	for attempt in 0 1 2 4 5; do if \
	LD_LIBRARY_PATH=$(CHERILIBS_ABS)/peripherals \
	CHERI_CONFIG=$$TMPDIR/simconfig \
	BERI_DEBUG_SOCKET=$(CHERISOCKET) $(SIM) -V $(HOME)/$(1).vcd -w +regDump $(SIM_TRACE_OPTS) -m $(TEST_CYCLE_LIMIT) > \
	    $(PWD)/$@; \
	then break; else false; fi; done

CLEAN_TEST = rm -r $$TMPDIR

WAIT_FOR_SOCKET = while ! test -e $(1); do sleep 0.1; done

MEMCONV=python ${TOOLS_DIR_ABS}/memConv.py
AS=mips64-as
LD=mips-linux-gnu-ld
OBJCOPY=mips64-objcopy
OBJDUMP=mips64-objdump

all: $(TEST_MEMS) $(TEST_CACHED_MEMS) $(TEST_DUMPS) $(TEST_CACHED_DUMPS) $(TEST_HEXS) $(TEST_CACHED_HEXS)

test: nosetest nosetest_cached

.PHONY: FORCE
FORCE:

test_hardware: altera-nosetest altera-nosetest_cached

$(CHERISOCKET):
	TMPDIR=$$(mktemp -d) && \
	cd $$TMPDIR && \
	cp ${CHERIROOT_ABS}/sw/mem.bin mem.bin && \
	$(MEMCONV) bsim && \
	$(COPY_PISM_CONFS) && \
	LD_LIBRARY_PATH=$(CHERILIBS_ABS)/peripherals \
	CHERI_CONFIG=$$TMPDIR/simconfig \
	$(SIM) &

# Because fuzz testing deals with lots of small files it is preferable to use
# find | xargs to remove them. For other cleans it is probably better to
# list the files explicitly.
clean_fuzz:
	find $(OBJDIR) $(LOGDIR) $(GXEMUL_LOGDIR) -name 'test_fuzz*' | xargs -r rm
	find $(FUZZ_TEST_DIR) -name 'test_fuzz*.s' | xargs -r rm

cleantest:
	rm -f $(CHERI_TEST_LOGS) $(CHERI_TEST_CACHED_LOGS)
	rm -f $(CHERI_TEST_MULTI_LOGS)
	rm -f $(GXEMUL_TEST_LOGS) $(GXEMUL_TEST_CACHED_LOGS)
	rm -f $(ALTERA_TEST_LOGS) $(ALTERA_TEST_CACHED_LOGS)
	rm -f $(L3_TEST_LOGS) $(L3_TEST_CACHED_LOGS)

clean: cleantest
	rm -f $(TEST_INIT_OBJECT) $(TEST_INIT_CACHED_OBJECT) $(TEST_LIB_OBJECT)
	rm -f $(TEST_INIT_MULTI_OBJECT)
	rm -f $(TEST_OBJS) $(TEST_ELFS) $(TEST_MEMS) $(TEST_DUMPS)
	rm -f $(TEST_CACHED_ELFS) $(TEST_CACHED_MEMS) $(TEST_CACHED_DUMPS)
	rm -f $(TEST_MULTI_ELFS) $(TEST_MULTI_MEMS) $(TEST_MULTI_DUMPS)
	rm -f log/*.log obj/*.mem obj/*.o obj/*.elf obj/*.dump
	rm -f $(TESTDIR)/*/*.pyc
	rm -f $(OBJDIR)/*.hex *.hex mem.bin

.PHONY: all clean cleantest clean_fuzz test nosetest nosetest_cached failnosetest
.SECONDARY: $(TEST_OBJS) $(TEST_ELFS) $(TEST_CACHED_ELFS) \
	$(TEST_MULTI_ELFS) $(TEST_CACHEDMULTI_ELFS) $(TEST_MEMS) \
	$(TEST_INIT_OBJECT) $(TEST_INIT_CACHED_OBJECT) \
	$(TEST_INIT_MULTI_OBJECT) $(TEST_LIB_OBJECT)

$(TOOLS_DIR_ABS)/debug/cherictl: $(TOOLS_DIR_ABS)/debug/cherictl.c $(TOOLS_DIR_ABS)/debug/cheri_debug.c
	$(MAKE) -C $(TOOLS_DIR_ABS)/debug/ cherictl

#
# Targets for unlinked .o files.  The same .o files can be used for both
# uncached and cached runs of the suite, so we just build them once.
#
$(OBJDIR)/test_%.o : test_%.s
	#clang  -c -fno-pic -target cheri-unknown-freebsd -integrated-as -o $@ $<
	$(AS) -EB -march=mips64 -mabi=64 -G0 -ggdb -defsym TEST_CP2=$(TEST_CP2) -o $@ $<


# Put DMA model makefile into its own file. This one is already ludicrously
# large.
ifeq ($(DMA),1)
DMADIR=$(CHERILIBS_ABS)/peripherals/DMA
vpath DMA% $(DMADIR)

include dmamodel.mk

DMA_LIB_OBJS=$(OBJDIR)/DMAAsm.o $(OBJDIR)/DMAControl.o

$(OBJDIR)/test_clang_dma%.o: test_clang_dma%.c $(OBJDIR)/DMAAsm.o $(OBJDIR)/DMAControl.o
	clang -I$(DMADIR) -Werror=all -g -c -fno-pic -target cheri-unknown-freebsd -integrated-as -o $@ $< -O3 -ffunction-sections -fno-builtin

# For some reasons, these need to be explicit, not implicit
$(OBJDIR)/DMAAsm.o: DMAAsm.c
	clang -Werror=all -I$(DMADIR) -c -fno-pic -target cheri-unknown-freebsd -integrated-as -o $@ $< -O3 -ffunction-sections

$(OBJDIR)/DMAControl.o: DMAControl.c
	clang -Werror=all -I$(DMADIR) -c -fno-pic -target cheri-unknown-freebsd -integrated-as -o $@ $< -O3 -ffunction-sections
endif


# Once the assembler works, we can try this version too:
#clang  -S -fno-pic -target cheri-unknown-freebsd -o - $<  | $(AS) -EB -march=mips64 -mabi=64 -G0 -ggdb -o $@ -

$(OBJDIR)/test_clang%.o : test_clang%.c
	clang -c -fno-pic -target cheri-unknown-freebsd -integrated-as -o $@ $<  -O3 -ffunction-sections

$(OBJDIR)/test_%.o : test_%.c
	mips-linux-gnu-gcc -c -EB -march=mips64 -mabi=64 -G0 -ggdb -o $@ $<

$(OBJDIR)/%.o: %.s
	$(AS) -EB -march=mips64 -mabi=64 -G0 -ggdb --defsym BERI_VER=$(BERI_VER) --defsym  TEST_CP2=$(TEST_CP2) -o $@ $<
	#clang  -c -fno-pic -target cheri-unknown-freebsd -integrated-as -o $@ $<

select_init: select_init.c
	gcc -o select_init select_init.c

#
# Targets for ELF images
#

#$(OBJDIR)/test_clang_dma_simple.elf : $(OBJDIR)/test_clang_dma_simple.o $(DMA_LIB_OBJS)\
	    #$(TEST_LDSCRIPT) \
	    #$(TEST_INIT_OBJECT) $(TEST_LIB_OBJECT) select_init
	#$(LD) -EB -G0 `./select_init $@`  $< -o $@ $(DMA_LIB_OBJS) -m elf64btsmip

$(OBJDIR)/startdramtest.elf: $(OBJDIR)/startdramtest.o $(TEST_LDSCRIPT)
	$(LD) -EB -G0 raw.ld $< -o $@ -m elf64btsmip

$(OBJDIR)/test_clang_dma%.elf : $(OBJDIR)/test_clang_dma%.o $(DMA_LIB_OBJS)\
	    $(TEST_LDSCRIPT) \
	    $(TEST_INIT_OBJECT) $(TEST_LIB_OBJECT) select_init
	$(LD) -EB -G0 -Ttest_dram.ld obj/lib.o $< -o $@ $(DMA_LIB_OBJS) -m elf64btsmip

$(OBJDIR)/test_%.elf : $(OBJDIR)/test_%.o \
	    $(TEST_LDSCRIPT) \
	    $(TEST_INIT_OBJECT) $(TEST_LIB_OBJECT) select_init
	$(LD) -EB -G0 `./select_init $@`  $< -o $@ -m elf64btsmip

$(OBJDIR)/test_%_cached.elf : $(OBJDIR)/test_%.o \
	    $(TEST_CACHED_LDSCRIPT) \
	    $(TEST_INIT_OBJECT) $(TEST_INIT_CACHED_OBJECT) \
	    $(TEST_LIB_OBJECT) select_init
	$(LD) -EB -G0 `./select_init $@`  $< -o $@ -m elf64btsmip

$(OBJDIR)/test_%_multi.elf : $(OBJDIR)/test_%.o \
	    $(TEST_MULTI_LDSCRIPT) \
	    $(TEST_INIT_MULTI_OBJECT) \
	    $(TEST_INIT_OBJECT) $(TEST_INIT_CACHED_OBJECT) \
	    $(TEST_LIB_OBJECT) select_init
	$(LD) -EB -G0 `./select_init $@`  $< -o $@ -m elf64btsmip

$(OBJDIR)/test_%_cachedmulti.elf : $(OBJDIR)/test_%.o \
	    $(TEST_CACHEDMULTI_LDSCRIPT) \
	    $(TEST_INIT_MULTI_OBJECT) \
	    $(TEST_INIT_OBJECT) $(TEST_INIT_CACHED_OBJECT) \
	    $(TEST_LIB_OBJECT) select_init
	$(LD) -EB -G0 `./select_init $@`  $< -o $@ -m elf64btsmip

#
# Convert ELF images to raw memory images that can be loaded into simulators
# or hardware.
#
$(OBJDIR)/%.mem : $(OBJDIR)/%.elf
	$(OBJCOPY) -S -O binary $< $@

# I instantiate this specifically so that it gets used to when test_clang_dma%
# is used to build a test directly.

$(OBJDIR)/startdramtest.mem: $(OBJDIR)/startdramtest.elf
	$(OBJCOPY) -S -O binary $< $@

#
# Convert ELF images to raw memory images that can be loaded into simulators
# or hardware.
#
$(OBJDIR)/%.hex : $(OBJDIR)/%.mem
	TMPDIR=$$(mktemp -d) && \
	cd $$TMPDIR && \
	cp $(CURDIR)/$< mem.bin && \
	$(MEMCONV) verilog && \
	cp initial.hex $(CURDIR)/$@ && \
	rm -r $$TMPDIR


#
# Provide an annotated disassembly for the ELF image to be used in diagnosis.
#
$(OBJDIR)/%.dump: $(OBJDIR)/%.elf
	$(OBJDUMP) -xsSD $< > $@

$(LOGDIR)/test_raw_trace.log: CHERI_TRACE_FILE=$(PWD)/log/test_raw_trace.trace
$(LOGDIR)/test_raw_trace_cached.log: CHERI_TRACE_FILE=$(PWD)/log/test_raw_trace_cached.trace

# The trace files need interaction from cherictl
# We fork the test, and use cherictl
# test_raw_trac, because % must be non-empty...
#
$(LOGDIR)/test_raw_trac%.log: $(OBJDIR)/test_raw_trac%.mem $(SIM) $(CHERICTL)
	rm -f $$CHERI_TRACE_FILE
	$(call PREPARE_TEST,$<) && \
	((BERI_DEBUG_SOCKET_0=$$TMPDIR/sock \
	CHERI_TRACE_FILE=$(CHERI_TRACE_FILE) \
	$(call RUN_TEST,$*); \
	$(CLEAN_TEST)) &) && \
	$(call WAIT_FOR_SOCKET,$$TMPDIR/sock) && \
	$(CHERICTL) setreg -r 12 -v 1 -p $$TMPDIR/sock && \
	$(CHERICTL) memtrace -v 6 -p $$TMPDIR/sock

#
# Target to execute a Bluespec simulation of the test suite; memConv.py needs
# fixing so that it accepts explicit sources and destinations but for now we
# can use a temporary directory so that parallel builds work.
$(LOGDIR)/test_clang_dma%.log: $(OBJDIR)/startdramtest.mem $(OBJDIR)/test_clang_dma%.mem $(SIM)
	$(call PREPARE_TEST,$<) && \
		cp $(PWD)/$(word 2, $^) . && \
		$(call REPEAT_5, CHERI_KERNEL=$(notdir $(word 2, $^)) $(RUN_TEST_COMMAND)); \
		$(CLEAN_TEST)

$(LOGDIR)/%.log : $(OBJDIR)/%.mem $(SIM)
	$(call PREPARE_TEST,$<) && $(call RUN_TEST,$*); $(CLEAN_TEST)

# The test won't be run, but attempting to build with the standard rules fails
$(LOGDIR)/test_clang_dma%_cached.log : ;

#
# Target to do a run of the test suite on hardware.
$(ALTERA_LOGDIR)/%.log : $(OBJDIR)/%.mem $(TOOLS_DIR_ABS)/debug/cherictl
	$(TOOLS_DIR_ABS)/debug/cherictl test -f $(CURDIR)/$< > $(CURDIR)/$@ && \
	sleep .1

#
# Target to run the hardware test suite on the simulator.
$(HWSIM_LOGDIR)/%.log : $(OBJDIR)/%.mem $(TOOLS_DIR_ABS)/debug/cherictl
	sleep 2
	while ! test -e /tmp/cheri_debug_listen_socket; do sleep 0.1; done
	TMPDIR=$$(mktemp -d) && \
	cd $$TMPDIR && \
	$(TOOLS_DIR_ABS)/debug/cherictl test -f $(CURDIR)/$< > $(CURDIR)/$@ && \
	rm -r $$TMPDIR
	killall -9 bluetcl
	rm /tmp/cheri_debug_listen_socket
	sleep 1

#
# Target to execute a gxemul simulation.  Gxemul is focused on running
# interactively which causes two problems: firstly there is no way to
# say on the command line that we want to run for only
# TEST_CYCLE_LIMIT cycles, and secondly gxemul assumes that there is
# an interactive terminal and hangs if stdin goes away. We get around
# this with the following glorious hackery to 1) feed gxemul commands
# to step TEST_CYCLE_LIMIT times then exit and 2) wait until gxemul
# closes stdin before exiting the pipeline.
#
$(GXEMUL_LOGDIR)/%_gxemul.log : $(OBJDIR)/%.elf
	(printf "step $(TEST_CYCLE_LIMIT)\nquit\n"; while echo > /dev/stdout; do sleep 0.01; done ) | \
	$(GXEMUL_BINDIR)/gxemul $(GXEMUL_OPTS) $< 2>&1 | \
	    $(GXEMUL_LOG_FILTER) >$@ || true


$(GXEMUL_LOGDIR)/%_gxemul_cached.log : $(OBJDIR)/%_cached.elf
	(printf "step $(TEST_CYCLE_LIMIT)\nquit\n"; while echo > /dev/stdout; do sleep 0.01; done ) | \
	$(GXEMUL_BINDIR)/gxemul $(GXEMUL_OPTS) $< 2>&1 | \
	    $(GXEMUL_LOG_FILTER) >$@ || true

max_cycles: max_cycles.c
	gcc -o max_cycles max_cycles.c

l3tosim: l3tosim.c
	gcc -o l3tosim l3tosim.c

ifeq ($(MULTI),1)
L3_MULTI=--nbcore 2
else
L3_MULTI=
endif

$(L3_LOGDIR)/%.log: $(OBJDIR)/%.hex l3tosim max_cycles
	test -d $(L3_LOGDIR) || mkdir $(L3_LOGDIR)
	l3mips --cycles `./max_cycles $@ 20000 300000` --uart-delay 0 --ignore HI --ignore LO --trace 2 $(L3_MULTI) $< 2> $@.err | ./l3tosim > $@ || true

# Simulate a failure on all unit tests
failnosetest: cleantest $(CHERI_TEST_LOGS)
	DEBUG_ALWAYS_FAIL=1 PYTHONPATH=tools nosetests $(NOSEFLAGS) $(TESTDIRS)

print-versions:
	nosetests --version

foo: $(CHERI_TEST_LOGS)

.PHONY: fuzz_run_tests fuzz_run_tests_cached fuzz_generate nose_fuzz nose_fuzz_cached
fuzz_run_tests: $(GXEMUL_FUZZ_TEST_LOGS) $(SIM_FUZZ_TEST_LOGS)

fuzz_run_tests_cached: $(GXEMUL_FUZZ_TEST_CACHED_LOGS) $(SIM_FUZZ_TEST_CACHED_LOGS)

fuzz_generate: $(FUZZ_SCRIPT)
	python $(FUZZ_SCRIPT) $(FUZZ_SCRIPT_OPTS) -d $(FUZZ_TEST_DIR)

# The rather unpleasant side-effect of snorting too much candy floss...
nose_fuzz: $(SIM) fuzz_run_tests
	PYTHONPATH=tools/sim CACHED=0 nosetests --with-xunit \
	    --xunit-file=nosetests_fuzz.xml $(NOSEFLAGS_UNCACHED) tests/fuzz || true

nose_fuzz_cached: $(SIM) fuzz_run_tests_cached
	PYTHONPATH=tools/sim CACHED=1 nosetests --with-xunit \
	    --xunit-file=nosetests_fuzz_cached.xml $(NOSEFLAGS) tests/fuzz || true


# Run unit tests using nose (http://somethingaboutorange.com/mrl/projects/nose/)

nosetest: nosetests_uncached.xml

nosetest_cached: nosetests_cached.xml

nosetests_multi: nosetests_multi.xml

nosetests_cachedmulti: nosetests_cachedmulti.xml

#
# Merge resuls of cached and uncached tests
#

nosetests_combined.xml: nosetests_uncached.xml nosetests_cached.xml xmlcat
	./xmlcat nosetests_uncached.xml nosetests_cached.xml > nosetests_combined.xml

#
# Use the target FORCE to force the xmk files to be rebuilt each time.
# This is done because Jenkins will complain if it doens't get a fresh XML
# file each time.

nosetests_uncached.xml: $(CHERI_TEST_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim CACHED=0 nosetests --with-xunit \
	    --xunit-file=nosetests_uncached.xml $(NOSEFLAGS_UNCACHED) \
	    $(TESTDIRS) || true

nosetests_cached.xml: $(CHERI_TEST_CACHED_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim CACHED=1 nosetests --with-xunit \
	    --xunit-file=nosetests_cached.xml $(NOSEFLAGS) $(TESTDIRS) || true

nosetests_multi.xml: $(CHERI_TEST_MULTI_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim MULTI1=1 nosetests --with-xunit \
	    --xunit-file=nosetests_multi.xml $(NOSEFLAGS) $(TESTDIRS) || true

nosetests_cachedmulti.xml: $(CHERI_TEST_CACHEDMULTI_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim MULTI1=1 CACHED=1 nosetests --with-xunit \
	    --xunit-file=nosetests_cachedmulti.xml $(NOSEFLAGS) $(TESTDIRS) || true

altera-nosetest: all $(ALTERA_TEST_LOGS)
	PYTHONPATH=tools/sim CACHED=0 LOGDIR=$(ALTERA_LOGDIR) nosetests \
	    $(NOSEFLAGS_UNCACHED) $(ALTERA_NOSEFLAGS) $(TESTDIRS) || true

altera-nosetest_cached: all $(ALTERA_TEST_CACHED_LOGS)
	PYTHONPATH=tools/sim CACHED=1 LOGDIR=$(ALTERA_LOGDIR) nosetests \
	    $(NOSEFLAGS) $(ALTERA_NOSEFLAGS) $(TESTDIRS) || true

hwsim-nosetest: $(CHERISOCKET) all $(HWSIM_TEST_LOGS)
	PYTHONPATH=tools/sim CACHED=0 LOGDIR=$(HWSIM_LOGDIR) nosetests \
	$(NOSEFLAGS_UNCACHED) $(HWSIM_NOSEFLAGS) $(TESTDIRS) || true

hwsim-nosetest_cached: $(CHERISOCKET) all $(HWSIM_TEST_CACHED_LOGS)
	PYTHONPATH=tools/sim CACHED=1 LOGDIR=$(HWSIM_LOGDIR) nosetests \
	    $(NOSEFLAGS) $(HWSIM_NOSEFLAGS) $(TESTDIRS) || true

nosetests_gxemul: nosetests_gxemul_uncached.xml

nosetests_gxemul_uncached.xml: $(GXEMUL_TEST_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/gxemul CACHED=0 nosetests --with-xunit \
	    --xunit-file=nosetests_gxemul_uncached.xml $(GXEMUL_NOSEFLAGS) \
	    $(TESTDIRS) || true

nosetests_gxemul_cached: nosetests_gxemul_cached.xml

nosetests_gxemul_cached.xml: $(GXEMUL_TEST_CACHED_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/gxemul CACHED=1 nosetests --with-xunit \
	    --xunit-file=nosetests_gxemul_cached.xml $(GXEMUL_NOSEFLAGS) \
	    $(TESTDIRS) || true

gxemul-build:
	rm -f -r $(GXEMUL_BINDIR)
	wget https://github.com/CTSRD-CHERI/gxemul/zipball/8d92b42a6ccdb7d94a2ad43f7e5e70d17bb7839c -O tools/gxemul/gxemul-testversion.zip --no-check-certificate
	unzip tools/gxemul/gxemul-testversion.zip -d tools/gxemul/
	cd $(GXEMUL_BINDIR) && ./configure && $(MAKE)

nosetests_l3: nosetests_l3.xml

nosetests_l3_cached: nosetests_l3_cached.xml

nosetests_l3_multi: nosetests_l3_multi.xml

nosetests_l3_cachedmulti: nosetests_l3_cachedmulti.xml

nosetests_l3.xml: $(L3_TEST_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim LOGDIR=$(L3_LOGDIR) nosetests --with-xunit \
	    --xunit-file=nosetests_l3.xml $(L3_NOSEFLAGS) $(TESTDIRS) || true

nosetests_l3_cached.xml: $(L3_TEST_CACHED_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim CACHED=1 LOGDIR=$(L3_LOGDIR) nosetests \
	    --with-xunit --xunit-file=nosetests_l3_cached.xml $(L3_NOSEFLAGS) \
	    $(TESTDIRS) || true

nosetests_l3_multi.xml: $(L3_TEST_MULTI_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim MULTI1=1 LOGDIR=$(L3_LOGDIR) nosetests \
	    --with-xunit --xunit-file=nosetests_l3_multi.xml $(L3_NOSEFLAGS) \
            $(TESTDIRS) || true

nosetests_l3_cachedmulti.xml: $(L3_TEST_CACHEDMULTI_LOGS) $(TEST_PYTHON) FORCE
	PYTHONPATH=tools/sim CACHED=1 MULTI1=1 LOGDIR=$(L3_LOGDIR) nosetests \
	    --with-xunit --xunit-file=nosetests_l3_cachedmulti.xml $(L3_NOSEFLAGS) \
            $(TESTDIRS) || true

xmlcat: xmlcat.c
	gcc -o xmlcat xmlcat.c -I/usr/include/libxml2 -lxml2 -lz -lm

cleanerror:
	find log -size 0 | xargs -r --verbose rm
