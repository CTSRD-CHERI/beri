#!/usr/bin/python
#-
# Copyright (c) 2011 Wojciech A. Koszek
# All rights reserved.
#
# This software was developed by SRI International and the University of
# Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-10-C-0237
# ("CTSRD"), as part of the DARPA CRASH research programme.
#
# @BERI_LICENSE_HEADER_START@
#
# Licensed to BERI Open Systems C.I.C. (BERI) under one or more contributor
# license agreements.  See the NOTICE file distributed with this work for
# additional information regarding copyright ownership.  BERI licenses this
# file to you under the BERI Hardware-Software License, Version 1.0 (the
# "License"); you may not use this file except in compliance with the
# License.  You may obtain a copy of the License at:
#
#   http://www.beri-open-systems.org/legal/license-1-0.txt
#
# Unless required by applicable law or agreed to in writing, Work distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations under the License.
#
# @BERI_LICENSE_HEADER_END@
#
# .sopc file parser for Altera IDE
#
from xml.dom import minidom
import os
import sys
import getopt

# MIPS specific offset related with CPU's memory layout. See MIPS R4000 manual,
# page 108.
g_virt_addr = 0x9000000000000000;

# Warning.
g_warning ="""\
/*****************************************************************************

 WARNING:

 This file has been automatically generated by tools/cheri_genfiles.py
 Do not modify it by hand.

*****************************************************************************/
""";

# We simply don't want use very long names for macros/variable names. Thus,
# we create a map between names from .sopc name to the easily understandable
# and short enough name for .bsv/.h macros.
g_periph_map = [
# From, To, Macro name
[ "mkMIPSTop_0.avalon_master_0", "jtag_uart_MIPS.avalon_jtag_slave", "AVN_JTAG_UART_BASE" ]
];

# This is simple table of hacked peripherials.
g_hacked_connections = [
# Macro name, address
[ "LOOPBACK_UART_BASE", "0x7f001000" ],
[ "CHERI_NET_TX", "0x7f002000" ],
[ "CHERI_NET_RX", "0x7f003000" ],
[ "CHERI_COUNT", "0x7f004000" ],
[ "DEBUG_JTAG_UART_BASE", "0x7f005000" ],
[ "CHERI_LEDS", "0x7f006000" ]
];

# Output format for this program. See usage() to understand it.
g_output_fmt = "c";


# Generate declaration.
def decl_output(name, value):
	phys_addr = int(value, 0);		# for Bluespec/Verilog
	virt_addr = g_virt_addr + phys_addr;	# For C after enabling MMU
	if (g_output_fmt == "c"):
		print "#define %s\t%#016x" % (name, virt_addr);
	elif ((g_output_fmt == "v") or (g_output_fmt == "b")):
		phys_addr /= 32;		# XXX: this requires explaination!
		print "`define %s\t'h%x" % (name, phys_addr);
	else:
		print "Unknown fmt. Internal error!";
		sys.exit(2);

# Take some relevant data about the connection in the SoC system and
# generates correctly formated output.
def connection_parse(source, dest, kind, name, value):
	# We're only interested in Avalon busses that start in
	# g_conn_from (e.g.: CPU data master interface)
	if (kind != "avalon"):
		return;
	# We're only interested in baseAddress for now
	if (name != "baseAddress"):
		return;
	# Find a map for the name.
	r_name = "UNDEFINED";
	for mapping in g_periph_map:
		(mapfrom, mapto, macroname) = mapping;
		if ((mapfrom != source) or (mapto != dest)):
			continue;
		r_name = macroname;
	if r_name == "UNDEFINED":
		return;
	decl_output(r_name, value);

# Parse file 'filename'. It builds XML tree and walks through it by calling
# connection_parse().
def file_parse(filename):
	system = minidom.parse(filename);
	# For all connections in the system
	for conn in system.getElementsByTagName("connection"):
		# Pick the connection source, destination and kind.
		kind = conn.getAttribute("kind");
		conn_start = conn.getAttribute("start");
		conn_end = conn.getAttribute("end");
		# For each parameter present in the connection
		params = conn.getElementsByTagName("parameter");
		for param in params:
			# Obtain the name of the parameter and its value
			name = param.getAttribute("name");
			value = param.getAttribute("value");
			# Pass it to connection_parse() and do whatever you
			# want there.
			connection_parse(conn_start, conn_end, kind, name,
				value);
	# After printing connection from the .sopc file, print out the
	# hardcoded (hacked) connections.
	for hacked_conn in g_hacked_connections:
		(name, value) = hacked_conn;
		decl_output(name, value);

def usage():
	print "usage:";
	print "\t./cheri_genfiles -b <data>.sopc";
	print "\t./cheri_genfiles -c <data>.sopc";
	print "\t./cheri_genfiles -v <data>.sopc";
	sys.exit(64);

def main():
	global g_output_fmt
	argc = len(sys.argv);
	if (argc < 3):
		usage();
	o = sys.argv[1]
	if (o == "-b"):
		g_output_fmt = "b";
	elif (o == "-c"):
		g_output_fmt = "c";
	elif (o == "-v"):
		g_output_fmt = "v";
	else:
		usage;
	print g_warning;
	file_parse(sys.argv[2]);

if __name__ == '__main__':
	main();
